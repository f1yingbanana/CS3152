/**
 * PolyShape
 * 
 * Unity API for Triangle adapted from:
 * http://tothemathmos.com/2013/05/17/advanced-triangulation-in-unity.html
 */

namespace PolyShape {
  using UnityEngine;
  using System.Collections;
  using System.IO;
  using System.Collections.Generic;
  using System;

  public class TriangleAPI {
    // Triangle's path relative to the project folder. Remember to add a slash!
    public string trianglePath = "/PolyShape/Triangle/";

    // Use this for initialization
    public Polygon2D Triangulate(PSLG pslg, float maxArea, float maxAngle) {
      if (pslg.vertices.Count == 0) {
        Debug.LogError("No vertices passed to triangle. hole count: " + pslg.holes.Count + ", vert count: " + pslg.vertices.Count);
        return new Polygon2D(new int[] { }, new Vector2[] { });
      } else {
        // Write poly file
        WritePolyFile(pslg);

        // Execute Triangle
        ExecuteTriangle(maxArea, maxAngle);

        // Read outout
        Vector2[] vertices = ReadVerticesFile();
        int[] triangles = ReadTrianglesFile();

        CleanUp();

        return new Polygon2D(triangles, vertices);
      }
    }

    void WritePolyFile(PSLG pslg) {
      try {
        string polyFilePath = Application.dataPath + trianglePath + "polygon.poly";

        if (File.Exists(polyFilePath)) {
          File.Delete(polyFilePath);
        }

        using (StreamWriter sw = File.CreateText(polyFilePath)) {
          sw.WriteLine("# polygon.poly");
          sw.WriteLine("# generated by Unity Triangle API");
          sw.WriteLine("#");
          // Vertices
          sw.WriteLine(pslg.GetNumberOfSegments() + " 2 0 1");
          sw.WriteLine("# The polyhedrons.");
          int boundaryMarker = 2;
          int i;
          for (i = 0; i < pslg.vertices.Count; i++) {
            if (i != 0 && pslg.boundaryMarkersForPolygons.Contains(i)) {
              boundaryMarker++;
            }
            sw.WriteLine(i + 1 + "\t" + pslg.vertices[i].x + "\t" + pslg.vertices[i].y + "\t" + boundaryMarker);
          }
          int offset = i;
          for (i = 0; i < pslg.holes.Count; i++) {
            sw.WriteLine("# Hole #" + (i + 1));
            int j;
            for (j = 0; j < pslg.holes[i].vertices.Count; j++) {
              sw.WriteLine((offset + j + 1) + "\t" + pslg.holes[i].vertices[j].x + "\t" + pslg.holes[i].vertices[j].y + "\t" + (boundaryMarker + i + 1));
            }
            offset += j;
          }

          // Line segments
          sw.WriteLine();
          sw.WriteLine("# Line segments.");
          sw.WriteLine(pslg.GetNumberOfSegments() + " 1");
          sw.WriteLine("# The polyhedrons.");
          boundaryMarker = 2;
          for (i = 0; i < pslg.segments.Count; i++) {
            if (i != 0 && pslg.boundaryMarkersForPolygons.Contains(i)) {
              boundaryMarker++;
            }
            sw.WriteLine(i + 1 + "\t" + (pslg.segments[i][0] + 1) + "\t" + (pslg.segments[i][1] + 1) + "\t" + boundaryMarker);
          }
          offset = i;
          for (i = 0; i < pslg.holes.Count; i++) {
            sw.WriteLine("# Hole #" + (i + 1));
            int j;
            for (j = 0; j < pslg.holes[i].segments.Count; j++) {
              sw.WriteLine((offset + j + 1) + "\t" + (offset + 1 + pslg.holes[i].segments[j][0]) + "\t" + (offset + 1 + pslg.holes[i].segments[j][1]) + "  " + (boundaryMarker + i + 1));
            }
            offset += j;
          }

          // Holes
          sw.WriteLine();
          sw.WriteLine("# Holes.");
          sw.WriteLine(pslg.holes.Count);
          for (i = 0; i < pslg.holes.Count; i++) {
            Vector2 point = pslg.GetPointInHole(pslg.holes[i]);
            sw.WriteLine((i + 1) + "\t" + point.x + "\t" + point.y + "\t # Hole #" + (i + 1));
          }
          sw.Close();
        }
      } catch (Exception e) {
        Debug.LogException(e);
      }
    }

    void ExecuteTriangle(float maxArea, float maxAngle) {
      try {
        System.Diagnostics.Process process = new System.Diagnostics.Process();

        if (Application.platform == RuntimePlatform.WindowsEditor || Application.platform == RuntimePlatform.WindowsPlayer) {
          process.StartInfo.FileName = Application.dataPath + trianglePath + "triangle.exe";
        } else {
          process.StartInfo.FileName = Application.dataPath + trianglePath + "triangle";
        }

        string argstr = "-pPq" + maxAngle + "a" + maxArea;
        process.StartInfo.Arguments = argstr + " \"" + Application.dataPath + trianglePath + "polygon.poly\"";
        process.StartInfo.RedirectStandardOutput = true;
        process.StartInfo.UseShellExecute = false;
        process.StartInfo.CreateNoWindow = true;
        process.Start();
        process.WaitForExit();
      } catch (System.Exception e) {
        Debug.LogException(e);
      }
    }

    Vector2[] ReadVerticesFile() {
      Vector2[] vertices = null;
      try {
        string outputVerticesFile = Application.dataPath + trianglePath + "polygon.1.node";

        StreamReader sr = File.OpenText(outputVerticesFile);

        string line = sr.ReadLine();
        int n = line.IndexOf("  ");
        int nVerts = int.Parse(line.Substring(0, n));
        vertices = new Vector2[nVerts];

        int whileCount = 0;

        while ((line = sr.ReadLine()) != null) {
          int index = -1;
          float x = 0f;
          float y = 0f;
          int c = 0;
          if (!line.Contains("#")) {
            string[] stringBits = line.Split(' ');

            foreach (string s in stringBits) {
              if (s != "" && s != " ") {
                if (c == 0) {
                  index = int.Parse(s);
                } else if (c == 1) {
                  x = float.Parse(s);
                } else if (c == 2) {
                  y = float.Parse(s);
                }

                c++;
              }
            }
          }

          if (index != -1) {
            vertices[index - 1] = new Vector2(x, y);
          }

          whileCount++;
        }

        sr.Close();
      } catch (Exception e) {
        Debug.LogException(e);
      }

      return vertices;
    }

    int[] ReadTrianglesFile() {
      List<int> triList = null;
      try {
        string outputTrianglesFile = Application.dataPath + trianglePath + "polygon.1.ele";

        using (StreamReader sr = File.OpenText(outputTrianglesFile)) {

          string line = sr.ReadLine();
          int n = line.IndexOf("  ");
          int nTriangles = int.Parse(line.Substring(0, n));
                //int[] triangles = new int[nTriangles * 3];
          triList = new List<int>(nTriangles * 3);

          int count = 0;

          while ((line = sr.ReadLine()) != null) {
            int index = -1;
            int c = 0;
            int[] tri = new int[3];
            if (!line.Contains("#")) {
              string[] stringBits = line.Split(' ');

              foreach (string s in stringBits) {
                if (s != "" && s != " ") {
                  if (c == 0) {
                    index = int.Parse(s);
                  } else if (c == 1) {
                    tri[0] = int.Parse(s) - 1;
                  } else if (c == 2) {
                    tri[1] = int.Parse(s) - 1;
                  } else if (c == 3) {
                    tri[2] = int.Parse(s) - 1;
                  }

                  c++;
                }
              }
            }

            if (index != -1) {
              triList.AddRange(tri);
            }

            count++;
          }

          sr.Close();
        }
      } catch (Exception e) {
        Debug.LogException(e);
      }

      return triList.ToArray();
    }

    void CleanUp() {
      try {
        File.Delete(Application.dataPath + trianglePath + "polygon.1.ele");
        File.Delete(Application.dataPath + trianglePath + "polygon.1.node");
        File.Delete(Application.dataPath + trianglePath + "polygon.poly");
      } catch (Exception e) {
        Debug.LogException(e);
      }
    }
  }
}

 